[{"id":"wordletoy_-_dev","timestamp":1686403020,"title":"WordleToy - Dev\r","description":"En esta publicación contaré el proceso de desarrollo de una pequeña recreación del famoso juego \"Wordle\" dividido en backend y frontend.\r","date":"June 10, 2023 10:17:00\r","modified_date":"","categories":["DEV","PROG","NEST","MONGO","TYPESCRIPT","WORDLE","CONTAINER","PODMAN","REACT","TAILWIND","TUTO"],"contents":["\r\n# WordleToy Backend\r\n\r\n![Wordle](https://github.com/Elias288/ElelisPage/blob/main/docs/src/assets/wordle/wordle.jpg?raw=true)\r\n\r\n<br>\r\n\r\n---\r\n\r\n## Introducción\r\n\r\nEl siguiente post se hará una explicacion del proceso de desarrollo del proyecto [WordleToy](https://github.com/Elias288/WordleToy/tree/master/wordleBackend) que se realizó con el objetivo de poner en practica usos de tecnologías y métodos. \r\n\r\nEn este post se explicará el desarrollo del backend para el funcionamiento del juego usando el framework NestJS y MongoDB en la base de datos.\r\n\r\nPara este proyecto se usó este árbol de directorios\r\n\r\n```sh\r\nWordleBackend\r\n  |\r\n  ├── src\r\n  |   |\r\n  │   ├─ dto\r\n  |   |   ├─ createWord.dto.ts\r\n  │   │   ├─ requestWord.dto.ts\r\n  │   │   └─ responseWord.dto.ts\r\n  |   |\r\n  │   ├─ schemas  \r\n  |   |   └─ word.schema.ts\r\n  |   |\r\n  │   └─ word  \r\n  |       ├─ word.controller.ts\r\n  |       ├─ word.module.ts\r\n  |       └─ word.service.ts\r\n  |\r\n  ├─ app.module.ts\r\n  └─ main.ts\r\n```\r\n\r\n<br>\r\n\r\n---\r\n\r\n## Reglas del Juego\r\n\r\nEl comienzo del desarrolllo comenzó con encontrar las reglas del juego, que nos indicarán el funcionamiento básico del juego.\r\n\r\nLas reglas son:\r\n\r\n> *El objetivo del juego es adivinar una palabra secreta de cinco letras en el menor número de intentos posible. Para enviar una respuesta, escriba cualquier palabra de cinco letras y pulse Intro. Todas tus adivinanzas deben ser palabras reales, de acuerdo con un diccionario de palabras de cinco letras que Wordle permite como adivinanzas.<br>\r\nAl acertar una letra de la palabra en la posición correcta está se marcará de color verde y al adivinar una letra pero fuera de su posición se marcará amarilla.*\r\n\r\n<br>\r\n\r\n---\r\n\r\n## Ambiente de desarrollo\r\n\r\nYa con eso en mente empecé la construcción del backend usando el framework *NestJs* haciendo uso de un ambiente de desarrollo en fedora construido en un contenedor de podman y así no tener que instalar los binarios del framework. El contenedor se generó con las siguientes instrucciones:\r\n\r\n```yaml\r\n# Containerfile\r\nFROM fedora:38                  # Usando la imagen de fedora v38\r\nRUN mkdir -p /usr/src/app       # Se crea un directorio \r\nWORKDIR /usr/src/app            # Y se lo define como el directorio de trabajo\r\n\r\nRUN dnf upgrade -y              # Actualizamos el SO\r\nRUN dnf install -y \\            # y empezamos a instalar todo lo que necesitaremos\r\n  procps && \\\r\n  dnf module install -y \\\r\n  nodejs\r\nRUN npm install -g npm@9.6.7 \\\r\n  @nestjs/cli\r\n```\r\n\r\n> \\* **Nota importante**: el contenedor del hambiente de desarrollo no cuenta con permisos necesarios, por lo tanto el framework se debe generar desde fuera o habilitarle los permisos necesarios a los directorios.\r\n\r\nPara generar el proyecto de nest se clonó un repositorio de github como se explica en las alternativas de instalación en la [documentación de NestJs](https://docs.nestjs.com/#installation).\r\n\r\nJunto con este \"hambiente\" en un contenedor además se necesitará una base de datos en MongoDB donde cargar todas las palabar permitidas en el juego, que tambien monté en un contenedor. \r\n\r\nPara poder gestionar esos contenedores, estos deben estar en un \"pod\".\r\n\r\nYa que todo eso es muy laborioso, para que se genere todo con un simple comando simplemente se crea un manifiesto *yaml* que se encargue de construir todos los contenedores con el comando de podman\r\n\r\n```sh\r\npodman play kube devEnvironment.yaml\r\n```\r\n\r\nEste archivo `devEnvironment.yaml` contiene las siguientes instrucciones:\r\n\r\n```yaml\r\n# devEnvironment.yaml\r\napiVersion: v1\r\nkind: Pod\r\nmetadata:\r\n  creationTimestamp: \"2023-05-31T13:44:16Z\"\r\n  labels:\r\n    app: wordle-pod\r\n  name: wordle-pod\r\nspec:\r\n  containers:\r\n  - name: backend\r\n    image: localhost/fedoradevnestjsimg:latest\r\n    stdin: true\r\n    tty: true\r\n    ports:\r\n      - containerPort: 3000\r\n        hostPort: 3000\r\n    volumeMounts:\r\n    - mountPath: /usr/src/app\r\n      name: fedoraVolume\r\n  - name: mongoDB\r\n    image: mongo\r\n    ports: \r\n      - containerPort: 27017\r\n        hostPort: 27017\r\n    environment:\r\n      - MONGO_INITDB_ROOT_USERNAME: root\r\n      - MONGO_INITDB_ROOT_PASSWORD: dbPassword\r\n    volumeMounts:\r\n    - mountPath: /data/db\r\n      name: wordleMongoDb\r\n  volumes:\r\n  - name: fedoraVolume\r\n    hostPath:\r\n      path: /mnt/c/.../WordleGame/wordleBackend\r\n      type: Directory\r\n  - name: wordleMongoDb\r\n    persistentVolumeClaim:\r\n        claimName: wordleMongoDb_-_db-volume\r\n```\r\n\r\n> \\* **Nota importante**: en este archivo hay que definir `MONGO_INITDB_ROOT_PASSWORD` del contenedor de `mongodb` y `path` en `fedoraVolume`\r\n\r\nLa definición de los volumenes es la parte más importante ya que con ellos podremos decirle al hambiente de desarrollo en que path debe tomar los archivos que trabajaremos, y en el caso de la bd guardar la información fuera del contenedor y que podrá ser reutilizada por otros contenedores en caso de que lo necesitemos.\r\n\r\n<br>\r\n\r","\r\n## Backend usando Nest y MongoDB\r\n\r\nLo que sigue es una explicación de codigo:\r\n\r\n### Conectar BD\r\n\r\nComo se explicó en [ambiente para el backend](#ambiente-para-el-backend) el servidor de MongoDB está en un contenedor que expone los puertos `27017` y la conexión se realiza a traves de `mongodb://localhost:27017/<databaseName>`.\r\n\r\nPara que nuestro servidor de nestjs pueda conectarse es necesario instalar las dependencias de `mongoose` y `@nestjs/mongoose` como se explica en las [Técnicas](https://docs.nestjs.com/techniques/mongodb) de NestJs.\r\n\r\n\r\n```ts\r\n// app.modules.ts\r\n@Module({\r\n  imports: [\r\n    MongooseModule.forRoot('mongodb://localhost:27017/wordleDb'),\r\n  ],\r\n})\r\nexport class AppModule {}\r\n```\r\n\r\n### Esquema de Palabras\r\n\r\nAhora que el backend está conectado al servidor de la BD es hora de crear el esquema que nos permitirá hacer uso de las funciones de mongoose para listar, guardar, modificar y borrar registros de la BD.\r\n\r\nEn este esquema solo es necesario guardar una palabra y también controladores.\r\n\r\n```ts\r\n// word.schemas.ts\r\nimport { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\r\n\r\n@Schema({\r\n  timestamps: true,\r\n})\r\nexport class Word {\r\n  @Prop({\r\n    required: true,\r\n    unique: true,\r\n    trim: true,\r\n  })\r\n  word: string;\r\n}\r\n\r\nexport const WordSchema = SchemaFactory.createForClass(Word);\r\n```\r\n\r\n### Modulo, Controlador y Servicios\r\n\r\nDespúes se generó la estructura de la api, empezando por el modulo `word.module.ts`, el controlador `word.controller.ts` y los servicios en `word.service.ts`.\r\n\r\nEn el modulo importaremos el esquema y el constructor:\r\n\r\n```ts\r\n// word.module.ts\r\n@Module({\r\n  imports: [\r\n    MongooseModule.forFeature([{ name: Word.name, schema: WordSchema }]),\r\n  ],\r\n  providers: [WordService],\r\n  controllers: [WordController],\r\n  exports: [WordService],\r\n})\r\n```\r\nEn los servicios se crearon las funciones básicas de listar todo, buscar por id, crear y eliminar.\r\n\r\n```ts\r\n// word.service.ts\r\n@Injectable()\r\nexport class WordService {\r\n  constructor(@InjectModel(Word.name) private wordleModel: Model<Word>) {}\r\n\r\n  findAll() {\r\n    return this.wordleModel.find();\r\n  }\r\n\r\n  findOne(id: string) {\r\n    return this.wordleModel.findById(id);\r\n  }\r\n\r\n  async create(createWord: CreateWordleDto) {\r\n    const newWord = new this.wordleModel(createWord);\r\n    return await newWord.save();\r\n  }\r\n\r\n  async delete(id: string) {\r\n    return this.wordleModel.findByIdAndDelete(id);\r\n  }\r\n}\r\n```\r\n\r\nLa función que traera una palabra random de todo el registro, que será la que se tendra que adivinar\r\n\r\n```ts\r\n// word.service.ts\r\nasync findRandomeOne() {\r\n  const randomWord = await this.wordleModel.aggregate([\r\n    { $sample: { size: 1 } },\r\n  ]);\r\n  return { wordId: randomWord[0]._id };\r\n}\r\n```\r\n\r\nY la función principal del juego, que es la encargada de comparar y devolver un resultado de la palabra escrita con la que se debe adiviniar.\r\n\r\nEl funcionamiento es el siguiente:\r\n\r\nLa palabra ingresada y la que se debe adivinar se divide por letra y se las recorre una a una, y por cada una se le asigna un numero del 0 al 2 dependiendo de:\r\n\r\n- Si la letra no está en la palabra a adivinar se le asigna un 0.\r\n- Si la letra está en la palabra y está en la posición correcta se le asigna un 1\r\n- Si la letra está en la palabra pero no está en la posición correcta se le asigna un 2\r\n\r\n```ts\r\n// word.service.ts\r\nasync requestWord(consult: requestWord): Promise<responseWord> {\r\n    const wordToGuess = await this.findOne(consult.wordId);\r\n    const arr = [...consult.updatedWord.split('')];\r\n    const wordToGuessArr = [...wordToGuess.word];\r\n\r\n    if (arr.length !== wordToGuessArr.length) {\r\n      throw new Error('Los arrays deben tener la misma longitud');\r\n    }\r\n\r\n    let gameStatus = true;\r\n    const resultado = [];\r\n    const wordToGuessArrCopy = wordToGuessArr.slice();\r\n\r\n    arr.forEach((caracter, i) => {\r\n      let estado = 0;\r\n      const caracterIndex = wordToGuessArrCopy.indexOf(caracter); // obtiene el indice del caracter\r\n\r\n      if (caracterIndex !== -1) {\r\n        estado = caracterIndex === i ? 1 : 2;\r\n        wordToGuessArrCopy[caracterIndex] = null; // lo elimina\r\n      } else {\r\n        estado = 0;\r\n      }\r\n\r\n      resultado.push({\r\n        letter: caracter,\r\n        status: estado,\r\n      });\r\n    });\r\n\r\n    gameStatus =\r\n      !resultado.some((letter) => letter.status === 0 || letter.status === 2) ||\r\n      consult.attempts === 0;\r\n\r\n    return {\r\n      wordId: consult.wordId,\r\n      letters: resultado,\r\n      attempts: consult.attempts,\r\n      attemptsCount: consult.attemptsCount,\r\n      done: gameStatus,\r\n    };\r\n  }\r\n```\r\n\r\nEl resultado final de está función es una objeto con todos los datos necesarios que indicarán al jugador si acertó o no.\r\n\r\n```json\r\n{\r\n  \"wordId\": string, // Id de la palabra a adivinar\r\n  \"letters\": Array<{letter, status}>, // Letras ingresadas y su estado\r\n  \"attempts\": number, // Número de intentos restantes\r\n  \"attemptsCount\": number, // Número de intentos realizados\r\n  \"done\": boolean, // Indicador de juego finalizado\r\n}\r\n```\r\n\r\nUn ejemplo:\r\n\r\n```json\r\n{\r\n  \"wordId\": \"sfgdfgbs4354\",\r\n  \"letters\": [\r\n    {\r\n      \"letter\": \"p\",\r\n      \"status\": 1\r\n    },\r\n    {\r\n      \"letter\": \"e\",\r\n      \"status\": 1\r\n    },\r\n    {\r\n      \"letter\": \"r\",\r\n      \"status\": 1\r\n    },\r\n    {\r\n      \"letter\": \"r\",\r\n      \"status\": 1\r\n    },\r\n    {\r\n      \"letter\": \"o\",\r\n      \"status\": 1\r\n    },\r\n  ],\r\n  \"attempts\": 2,\r\n  \"attemptsCount\": 3,\r\n  \"done\": true\r\n}\r\n```\r\n\r\nPara controlar los tipos de datos que serán enviados y recibidos, antes de definir los controladores definiremos los DTOs. Estos se encargarán de verificar los tipos de datos y si son obligatiorios o no.\r\n\r\n```ts\r\nexport class responseWord {\r\n  @IsString()\r\n  @IsNotEmpty()\r\n  wordId: string;\r\n\r\n  letters: letterStatus[];\r\n\r\n  @IsNumber()\r\n  @IsOptional()\r\n  attempts: number;\r\n\r\n  @IsNumber()\r\n  @IsOptional()\r\n  attemptsCount: number;\r\n\r\n  @IsBoolean()\r\n  @IsOptional()\r\n  done: boolean;\r\n}\r\n\r\ninterface letterStatus {\r\n  letter: string;\r\n  status: number;\r\n}\r\n```\r\n\r\nEn el controlador se definen las rutas de la API y a que servicios seran llamados desde estos.\r\n\r\n```ts\r\n// word.controller.ts\r\n@Controller('word')\r\nexport class WordController {\r\n  constructor(private wordService: WordService) {}\r\n\r\n  @Get()\r\n  findAll() {\r\n    return this.wordService.findAll();\r\n  }\r\n\r\n  @Get('random')\r\n  findRandomOne() {\r\n    return this.wordService.findRandomeOne();\r\n  }\r\n\r\n  @Post()\r\n  async createWord(@Body() body: CreateWordleDto) {\r\n    try {\r\n      return await this.wordService.create(body);\r\n    } catch (error) {\r\n      if (error.code === 11000) {\r\n        throw new ConflictException('Word already exists.');\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  @Post('requestWord')\r\n  async submitWord(@Body() body: requestWord): Promise<responseWord> {\r\n    return await this.wordService.requestWord(body);\r\n  }\r\n\r\n  @Delete(':id')\r\n  @HttpCode(204)\r\n  async deleteWordle(@Param('id') id: string) {\r\n    const wordle = await this.wordService.delete(id);\r\n    if (!wordle) throw new NotFoundException('Word not found');\r\n    return wordle;\r\n  }\r\n}\r\n```\r\n\r\nResultado de llamar a la función `findRandomOne`\r\n\r\n![WordleBackend](https://github.com/Elias288/ElelisPage/blob/main/docs/src/assets/wordle/WordleBackend.png?raw=true)\r\n\r\n## Siguiente paso\r\n\r\nCon todo esto ya tenemos una API con el que se puede jugar, lo que faltaría es construir un frontend que permita al jugador ingresarle las palabras y juegar.\r\n\r\nEn el siguiente publicación se explica el [desarrollo del frontend de WordleToy](#/blog/post/wordletoy_-_frontend)\r\n\r","\r\n# WordleToy Frontend\r\n\r\n![Wordle](https://github.com/Elias288/ElelisPage/blob/main/docs/src/assets/wordle/wordle.jpg?raw=true)\r\n\r\n<br>\r\n\r\n---\r\n\r\n## Introducción\r\n\r\nEl siguiente post se hará una explicacion del proceso de desarrollo del proyecto [WordleToy](https://github.com/Elias288/WordleToy/tree/master/wordle/wordleFrontend).\r\n\r\nEn este post se explicará el desarrollo del Frontend del juego usando el framwork Vite + React con typescript que se conectará al backend que se construyó para el juego.\r\n\r\nPara este proyecto se usó este árbol de directorios\r\n\r\n```sh\r\nWordleFrontend\r\n  │\r\n  ├── src\r\n  │   │\r\n  │   ├─ api\r\n  │   │   └─ wordle.api.ts\r\n  │   │  \r\n  │   ├─ components\r\n  |   |   ├─ Wordle.tsx\r\n  │   │   ├─ WordleForm.tsx\r\n  |   |   └─ WordleItem.tsx\r\n  │   │\r\n  │   ├─ context\r\n  │   │   ├─ useWord.tsx\r\n  |   |   └─ WordleContext.tsx\r\n  │   │\r\n  │   ├─ intefaces\r\n  |   |   └─ word.interface.ts\r\n  │   │\r\n  │   ├─ App.tsx\r\n  │   ├─ index.css\r\n  │   └─ main.tsx\r\n  │\r\n  └─ index.html\r\n```\r\n\r\n---\r\n\r\n## Reglas del Juego\r\n\r\nEl comienzo del desarrolllo comenzó con encontrar las reglas del juego, que nos indicarán el funcionamiento básico del juego.\r\n\r\nLas reglas son:\r\n\r\n> *El objetivo del juego es adivinar una palabra secreta de cinco letras en el menor número de intentos posible. Para enviar una respuesta, escriba cualquier palabra de cinco letras y pulse Intro. Todas tus adivinanzas deben ser palabras reales, de acuerdo con un diccionario de palabras de cinco letras que Wordle permite como adivinanzas.<br>\r\nAl acertar una letra de la palabra en la posición correcta está se marcará de color verde y al adivinar una letra pero fuera de su posición se marcará amarilla.*\r\n\r\n<br>\r\n\r\n---\r\n\r\n## Conexión con el backend\r\n\r\nPara comenzar nuestro Frontend definiremos los llamados a nuestra API del juego en `wordle.api.ts`\r\n\r\n```ts\r\n// Dirección de la API\r\nconst API = 'http://localhost:3000/api' \r\n\r\n// Función de obtener el id de una palabra random de la bd\r\nexport const getRandomWordRequest = () => fetch(`${API}/word/random`)\r\n\r\n// Función de envió de palabra a la API\r\nexport const postWordRequest = (updatedWord: SendWord) =>\r\n  fetch(`${API}/word/requestWord`, {\r\n    method: 'POST',\r\n    body: JSON.stringify(updatedWord),\r\n    headers: {\r\n      'Content-Type': 'application/json'\r\n    }\r\n  })\r\n```\r\n\r\n<br>\r\n\r","\r\n## Interfaces\r\n\r\nComo se está trabajando en Vite + React con Typescript debemos definir las intefaces que nos permitirán trabajar con los tipos de datos correctos para cada campo, de lo que la API nos devuelva.\r\n\r\nPara eso, en `word.interface.ts` definiremos nuestra interfaz `Word` donde estarán definidos todos sus campos que si recordamos es lo que retorna la función `requestWord`. del backend\r\n\r\n```ts\r\n// word.interface.ts\r\nexport interface Word {\r\n  wordId: string;\r\n  updatedWord: string;\r\n  attempts: number;\r\n  attemptsCount: number;\r\n  letters: Array<Letter>;\r\n  done: boolean;\r\n}\r\n\r\nexport interface Letter {\r\n  letter: string;\r\n  status: number;\r\n}\r\n```\r\n\r\nComo esta interfaz la vamos a usar tambien para recibir el id de una palabra random y tambien para enviar una respuesta al backend, necesitamos indicarle que datos serán necesarios y no para cada caso, de la siguiente forma.\r\n\r\n- En el caso de la palabra random solo se recibe la id, asi que se omiten todos los demás campos.\r\n- En el caso de enviar una respuesta, omitiremos el array de letras y el estado.\r\n\r\n```ts\r\n// word.interface.ts\r\nexport type RandomWord =  Omit<Word, 'updatedWord' | 'letters' | 'done' | 'attempts' | 'attemptsCount' >\r\nexport type SendWord = Omit<Word, 'letters' | 'done' >\r\n```\r\n\r\n## Contexto de Frontend\r\n\r\nPara que todos los componentes que se creen en este framework cuenten con los datos que se necesarios, crearemos un contexto que será el encargado de enviar y recibir datos con el backend.\r\n\r\nPara eso definimos las interfaces y creamos el contexto:\r\n```tsx\r\n// WordleContext.tsx\r\ninterface Props {\r\n  children: React.ReactNode,\r\n}\r\ninterface WordleContextValues {\r\n  word: RandomWord\r\n  resp: Word[]\r\n  requestWord: (word: SendWord) => void\r\n  restart: () => void\r\n}\r\n\r\nexport const WordleContext = createContext<WordleContextValues>({\r\n  word: { wordId: '' },\r\n  resp: [],\r\n  requestWord: () => { },\r\n  restart: () => { },\r\n})\r\n```\r\n\r\nY definimos nuestro contexto\r\n\r\n```tsx\r\n// WordleContext.tsx\r\nexport const WordleProvider: React.FC<Props> = ({ children }) => {\r\n  const [word, setWord] = useState<RandomWord>({ wordId: '' })\r\n  const [resp, setResp] = useState<Word[]>([])\r\n\r\n  // Obtiene una palabra random al cargar el componente\r\n  useEffect(() => {\r\n    getRandomWordRequest()\r\n      .then(res => res.json())\r\n      .then(data => setWord(data))\r\n}, [])\r\n\r\n  // Función que reinicia el juego\r\n  const restart = () => {\r\n    getRandomWordRequest()\r\n      .then(res => res.json())\r\n      .then(data => setWord(data))\r\n    setResp([])\r\n  }\r\n\r\n  // Función que recibe una palabra y consulta si se acertó\r\n  const requestWord = async (word: SendWord) => {\r\n    const res = await postWordRequest(word);\r\n    const data = await res.json();\r\n    setResp([...resp, data]);\r\n  }\r\n\r\n  return (\r\n    <WordleContext.Provider\r\n      value={{\r\n        word,\r\n        resp,\r\n        requestWord,\r\n        restart\r\n      }}\r\n    >\r\n      {children}\r\n    </WordleContext.Provider>\r\n  )\r\n}\r\n```\r\n\r\nTodos los componentes que estén dentro de este \"Contexto\" podrán acceder a sus variables y funciones.\r\n\r","\r\n## Presentación del juego\r\n\r\nYa con toda la logica interna definida, podemos empezar a trabajar en la presentación del juego, lo que va a ver el jugado.\r\n\r\n### WordleItem\r\n\r\nEmpezando por el item, aquí se tomará cada letra que llegue junto con su estado y dependiendo si este es 0, 1 o 2 se le dará un color. Recordando que:\r\n- 0 indica que la letra no está en la palabra, se lo deja en gris.\r\n- 1 indica que la letra está en la palabra y en la posición correcta y se le asigna el color verde.\r\n- 2 indica que la letra está en la palabra pero no en la posición correcta y se le asigna el color amarillo.\r\n\r\n```tsx\r\ninterface Props {\r\n  word: Letter\r\n}\r\n\r\nfunction WordleItem({ word }: Props) {\r\n  return (\r\n    word.status === 0 ? (\r\n      <div className=\"bg-zinc-500 flex-auto text-center p-2 w-10 rounded-lg uppercase\" >\r\n        {word.letter}\r\n      </div>\r\n    ) : (\r\n      word.status === 1 ? (\r\n        <div className=\"bg-green-500 flex-auto text-center p-2 w-10 rounded-lg uppercase\" >\r\n          {word.letter}\r\n        </div>\r\n      ) : (\r\n        <div className=\"bg-yellow-500 flex-auto text-center p-2 w-10 rounded-lg uppercase\" >\r\n          {word.letter}\r\n        </div>\r\n      )\r\n    )\r\n  );\r\n}\r\n\r\nexport default WordleItem;\r\n```\r\n\r\n### WordleForm\r\n\r\nLo importante del Form es llamar a las funciones del contexto que permita enviar la palabra ingresada, recibir y mostrar la respuesta del backend. Aqui un ejemplo reducido del formulario\r\n\r\n```tsx\r\nfunction WordleForm() {\r\n  const { resp, word, requestWord, restart } = useWord()\r\n  const [attempts, setattempts] = useState<number>(4)\r\n  const [attemptsCount, setattemptsCount] = useState<number>(0)\r\n  const [updatedWord, setUpdatedWord] = useState({\r\n    input1: '', input2: '', input3: '', input4: '', input5: '',\r\n  })\r\n  ...\r\n\r\n  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {\r\n    // solo permitir letras\r\n    const result = e.target.value.replace(/[^abcdefghijklmnñopqrstuvwxyz]/gi, '');\r\n    // guardar cada letra para despúes formar la palabra\r\n    setUpdatedWord({ ...updatedWord, [e.target.name]: result })\r\n    ...\r\n  }\r\n\r\n  const handleSubmit = (e: FormEvent<HTMLFormElement>) => {\r\n    e.preventDefault()\r\n    // reducir cada intento\r\n    setattempts(attempts - 1)\r\n    // y sumar la cantidad de intentos\r\n    setattemptsCount(attemptsCount + 1)\r\n    // verificar que no haya espacios vacios\r\n    if (updatedWord.input1 !== '' && updatedWord.input2 !== '' && updatedWord.input3 !== '' && updatedWord.input4 !== '' && updatedWord.input5 !== '') {\r\n      // formar la palabra\r\n      const sendUpdatedWord = `${updatedWord.input1}${updatedWord.input2}${updatedWord.input3}${updatedWord.input4}${updatedWord.input5}`\r\n\r\n      // enviar la respuesta al backend\r\n      requestWord({\r\n        wordId: word.wordId,\r\n        updatedWord: sendUpdatedWord,\r\n        attempts,\r\n        attemptsCount\r\n      })\r\n\r\n      ...\r\n    }\r\n  }\r\n\r\n  return (\r\n    <>\r\n      {\r\n        resp.length > 0 && !resp[resp.length - 1].done || resp.length === 0 ? (\r\n          <form onSubmit={handleSubmit} >\r\n            <div className=\"inline-flex w-full text-white bg-zinc-700 justify-center box-border gap-x-1\" >\r\n              <input\r\n                  type=\"text\"\r\n                  value={updatedWord.input1}\r\n                  className=\"bg-zinc-500 flex-auto text-center p-2 w-10 rounded-lg uppercase\"\r\n                  name=\"input1\"\r\n                  onChange={handleChange}\r\n                  onKeyUp={changeFocus}\r\n                  maxLength={1}\r\n                  ...\r\n                  autoFocus\r\n              />\r\n              ...\r\n              <button></button>\r\n            </div>\r\n          </form>\r\n        ) : (\r\n          <>\r\n            <button className=\"bg-blue-500 p-2 text-white rounded-md hover:bg-blue-700\" onClick={restartAll} > Restart </button>\r\n          </>\r\n        )\r\n      }\r\n    </>\r\n  )\r\n}\r\n\r\nexport default WordleForm;\r\n```\r\n\r\n\r\n### Wordle\r\n\r\nPor último el componente que engloba las 2 anteriores, que se encargará de listar los intentos.\r\n\r\n```tsx\r\nfunction Wordle() {\r\n  const { resp } = useWord()\r\n\r\n  return (\r\n    <div className=\"p-4 w-[500px]\">\r\n      <h1 className=\"w-full font-bold text-2xl text-center pb-4\">Wordle Toy</h1>\r\n      <div className=\"p-2 bg-zinc-700\">\r\n        {\r\n          resp.map((words, index) => {\r\n            return (\r\n              <div key={index} className=\"inline-flex w-full pb-1 text-white justify-center box-border gap-x-1\">\r\n                {\r\n                  words.letters.map((letter, index) => {\r\n                    return (\r\n                      <WordleItem word={letter} key={index}/>\r\n                    )\r\n                  })\r\n                }\r\n              </div>\r\n            )\r\n          })\r\n        }\r\n\r\n        <WordleForm />\r\n        <p className=\"text-white\">Intentos: {resp.length === 0 ? 0 : resp[resp.length - 1].attemptsCount + 1} de 5</p>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Wordle;\r\n```\r\n\r\nResultado del Frontend, un juego terminado:\r\n\r\n![WorleFrontend](https://github.com/Elias288/ElelisPage/blob/main/docs/src/assets/wordle/WordleFrontend.png?raw=true)\r\n\r\n<br>\r\n\r\n---\r\n\r\n\r\n# Conclusión\r\n\r\nEn este proyecto se afrontaron muchos retos de programación y utilización tecnologías nuevas que generarón un crecimiento en el entendimiento de estas y experiencia para proximos proyectos en los que se enfrenten a retos similares. \r\n\r\nFue una experiencia interesante y más con el uso de inteligencia artifical para generar partes del código que fue una agradable sorpresa.\r\n\r\nEspero que sea de utilidad para alguien más que a mi.\r\n\r\n<small style=\"display: block; text-align: right;\">Elias Bianchi</small>\r\n"]},{"id":"primera_publicacion","timestamp":1686313800,"title":"Primera Publicación\r","description":"Primera publicación en el blog, descripción de intenciones y propósitos.\r","date":"June 09, 2023 09:30:00\r","modified_date":"June 12, 2023 18:38:00\r","categories":["WELLCOME","INFO"],"contents":["\r\n# Primera Publicación\r\n\r\nEste *\"blog\"* está orientado a llevar un registro de desarrollo, investigaciones personales de tecnología, curiosidades y más.\r\n\r\nTodo el que quiera está invitado a leer y hacer un seguimiento de todos los temas publicaados aquí, que prometo mantener actualizado.\r\n\r\nLos codigos de los proyectos los podrás encontrar en mi repositorio de github [github.com/Elias288](https://github.com/Elias288?tab=repositories) o en mi espacio de codepen [codepen.io/sbianchi](https://codepen.io/sbianchi).\r\n\r\nEspero que te sea de utlidad todo lo que veas aquí.\r\n\r\n<small style=\"display: block; text-align: right;\">Elias Bianchi</small>\r\n"]}]